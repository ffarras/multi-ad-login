<?php
// Exit if accessed directly.
if (! defined('ABSPATH')) {
    exit;
}

/**
 * IMPORTANT SECURITY NOTE:
 * You MUST define a strong, unique encryption key in your wp-config.php file.
 * This key is CRUCIAL for the security of your stored bind passwords.
 *
 * Add the following line to your wp-config.php file, replacing 'YOUR_VERY_STRONG_RANDOM_KEY_HERE_AT_LEAST_32_CHARS'
 * with a truly random string of at least 32 characters (e.g., generated by a password manager or a secure random string generator).
 *
 * define('MADL_AD_BIND_PASSWORD_KEY', 'YOUR_VERY_STRONG_RANDOM_KEY_HERE_AT_LEAST_32_CHARS');
 *
 * If this key is compromised, all encrypted bind passwords can be decrypted.
 */
if (! defined('MADL_AD_BIND_PASSWORD_KEY')) {
    // Fallback for development/testing, but a warning should be logged.
    // In production, this should NEVER be the case.
    define('MADL_AD_BIND_PASSWORD_KEY', 'default_dev_key_change_this_in_production_1234567890');
    MADL_Logger::log("WARNING: MADL_AD_BIND_PASSWORD_KEY is not defined in wp-config.php. Using a default key. THIS IS INSECURE FOR PRODUCTION!", 'CRITICAL');
}


class MADL_Db
{

    private static $table_name_static = '';
    private $table_name_instance = '';

    public function __construct()
    {
        global $wpdb;
        self::$table_name_static = $wpdb->prefix . 'madl_ad_profiles';
        $this->table_name_instance = $wpdb->prefix . 'madl_ad_profiles';
    }

    /**
     * Get the fully qualified table name.
     * @return string
     */
    private static function get_table_name()
    {
        global $wpdb;
        if (empty(self::$table_name_static)) {
            self::$table_name_static = $wpdb->prefix . 'madl_ad_profiles';
        }
        return self::$table_name_static;
    }

    /**
     * Encrypts a given password using AES-256-CBC.
     *
     * @param string $password The plain-text password to encrypt.
     * @return array|false An array containing 'encrypted_password' and 'iv' on success, false on failure.
     */
    private function encrypt_password($password)
    {
        $key = MADL_AD_BIND_PASSWORD_KEY;
        $cipher = 'aes-256-cbc';
        $iv_length = openssl_cipher_iv_length($cipher);
        $iv = openssl_random_pseudo_bytes($iv_length); // Generate a random IV

        if ($iv === false) {
            MADL_Logger::log("Failed to generate IV for password encryption.", 'ERROR');
            return false;
        }

        $encrypted_password = openssl_encrypt($password, $cipher, $key, 0, $iv);

        if ($encrypted_password === false) {
            MADL_Logger::log("Failed to encrypt password.", 'ERROR');
            return false;
        }

        // Return base64 encoded IV and encrypted password for safe storage
        return array(
            'encrypted_password' => base64_encode($encrypted_password),
            'iv'                 => base64_encode($iv)
        );
    }

    /**
     * Decrypts an encrypted password using AES-256-CBC.
     *
     * @param string $encrypted_password_b64 The base64 encoded encrypted password.
     * @param string $iv_b64 The base64 encoded Initialization Vector.
     * @return string|false The decrypted password on success, false on failure.
     */
    private function decrypt_password($encrypted_password_b64, $iv_b64)
    {
        $key = MADL_AD_BIND_PASSWORD_KEY;
        $cipher = 'aes-256-cbc';

        $encrypted_password = base64_decode($encrypted_password_b64);
        $iv = base64_decode($iv_b64);

        if ($encrypted_password === false || $iv === false) {
            MADL_Logger::log("Invalid base64 encoding for encrypted password or IV during decryption.", 'ERROR');
            return false;
        }

        // Check if IV length matches expected length for the cipher
        $iv_length = openssl_cipher_iv_length($cipher);
        if (strlen($iv) !== $iv_length) {
            MADL_Logger::log("IV length mismatch during decryption. Expected {$iv_length} bytes, got " . strlen($iv) . " bytes.", 'ERROR');
            return false;
        }

        $decrypted_password = openssl_decrypt($encrypted_password, $cipher, $key, 0, $iv);

        if ($decrypted_password === false) {
            MADL_Logger::log("Failed to decrypt password. Check key and IV.", 'ERROR');
            return false;
        }

        return $decrypted_password;
    }

    /**
     * Create the AD profiles table.
     * Added 'bind_password_iv' column for encryption.
     */
    public static function create_table()
    {
        global $wpdb;
        $table_name = self::get_table_name();
        $charset_collate = $wpdb->get_charset_collate();

        if (empty($charset_collate)) {
            $charset_collate = "DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci";
            MADL_Logger::log("Warning: \$wpdb->get_charset_collate() was empty. Using fallback: " . $charset_collate, 'WARNING');
        }

        $sql = "CREATE TABLE {$table_name} (
            id mediumint(9) NOT NULL AUTO_INCREMENT,
            profile_name varchar(255) NOT NULL,
            is_default tinyint(1) NOT NULL DEFAULT 0,
            domain_identifier varchar(255) DEFAULT NULL,
            base_dn varchar(255) NOT NULL,
            domain_controllers text NOT NULL,
            port smallint(5) UNSIGNED NOT NULL DEFAULT 389,
            use_tls tinyint(1) NOT NULL DEFAULT 0,
            use_ssl tinyint(1) NOT NULL DEFAULT 0,
            allow_self_signed tinyint(1) NOT NULL DEFAULT 0,
            network_timeout tinyint(3) UNSIGNED NOT NULL DEFAULT 5,
            account_suffixes text DEFAULT NULL,
            bind_username varchar(255) DEFAULT NULL,
            bind_password text DEFAULT NULL,
            bind_password_iv varchar(255) DEFAULT NULL, -- New column for IV
            PRIMARY KEY  (id),
            UNIQUE KEY unique_profile_name (profile_name),
            KEY domain_identifier_key (domain_identifier)
        ) {$charset_collate};";

        MADL_Logger::log("Preparing to execute dbDelta. SQL: " . $sql, 'DEBUG');

        require_once ABSPATH . 'wp-admin/includes/upgrade.php';

        ob_start();
        $dbdelta_results = dbDelta($sql);
        $dbdelta_buffered_output = ob_get_clean();

        if (!empty($dbdelta_buffered_output)) {
            MADL_Logger::log("Direct output captured from dbDelta: " . trim($dbdelta_buffered_output), 'DEBUG');
        }

        if (is_array($dbdelta_results) && !empty($dbdelta_results)) {
            MADL_Logger::log("dbDelta execution results (array): " . print_r($dbdelta_results, true), 'DEBUG');
            foreach ($dbdelta_results as $result_key => $result_message) {
                if (
                    stripos($result_message, 'error') !== false ||
                    (stripos($result_message, 'created') === false &&
                        stripos($result_message, 'altered') === false &&
                        stripos($result_message, 'already up-to-date') === false &&
                        stripos($result_message, 'already exists') === false)
                ) {
                    MADL_Logger::log("dbDelta message for {$result_key}: {$result_message}", 'WARNING');
                }
            }
        } else {
            MADL_Logger::log("dbDelta did not return specific results (or table was up to date).", 'DEBUG');
        }

        MADL_Logger::log("Database table {$table_name} checked/created (dbDelta process completed).", 'INFO');

        if (!empty($wpdb->last_error)) {
            MADL_Logger::log("WPDB error after dbDelta: " . $wpdb->last_error, 'ERROR');
        }
    }

    /**
     * Add a new AD profile.
     * Encrypts bind_password before saving.
     *
     * @param array $data Profile data.
     * @return int|false Inserted ID or false on failure.
     */
    public function add_ad_profile($data)
    {
        global $wpdb;
        $table_name = $this->table_name_instance;

        if (empty($table_name)) {
            $table_name = self::get_table_name();
            MADL_Logger::log("Warning: Instance table name was empty in add_ad_profile. Using static getter.", 'WARNING');
        }

        if (! empty($data['is_default']) && $data['is_default']) {
            $wpdb->update($table_name, array('is_default' => 0), array('is_default' => 1), array('%d'), array('%d'));
            MADL_Logger::log("Cleared previous default AD profiles.", 'DEBUG');
        }

        $encrypted_bind_password = null;
        $bind_password_iv = null;

        // Encrypt bind_password if provided
        if (isset($data['bind_password']) && !empty($data['bind_password'])) {
            $encryption_result = $this->encrypt_password($data['bind_password']);
            if ($encryption_result) {
                $encrypted_bind_password = $encryption_result['encrypted_password'];
                $bind_password_iv = $encryption_result['iv'];
            } else {
                MADL_Logger::log("Failed to encrypt bind password for new profile: " . $data['profile_name'], 'ERROR');
                return false; // Prevent saving if encryption fails
            }
        }

        $insert_data = array(
            'profile_name'        => sanitize_text_field($data['profile_name']),
            'is_default'          => ! empty($data['is_default']) ? 1 : 0,
            'domain_identifier'   => isset($data['domain_identifier']) ? sanitize_text_field($data['domain_identifier']) : null,
            'base_dn'             => sanitize_text_field($data['base_dn']),
            'domain_controllers'  => sanitize_textarea_field($data['domain_controllers']),
            'port'                => isset($data['port']) ? absint($data['port']) : 389,
            'use_tls'             => ! empty($data['use_tls']) ? 1 : 0,
            'use_ssl'             => ! empty($data['use_ssl']) ? 1 : 0,
            'allow_self_signed'   => ! empty($data['allow_self_signed']) ? 1 : 0,
            'network_timeout'     => isset($data['network_timeout']) ? absint($data['network_timeout']) : 5,
            'account_suffixes'    => isset($data['account_suffixes']) ? sanitize_textarea_field($data['account_suffixes']) : null,
            'bind_username'       => isset($data['bind_username']) ? sanitize_text_field($data['bind_username']) : null,
            'bind_password'       => $encrypted_bind_password, // Store encrypted password
            'bind_password_iv'    => $bind_password_iv,        // Store IV
        );

        $formats = array(
            '%s',
            '%d',
            '%s',
            '%s',
            '%s',
            '%d',
            '%d',
            '%d',
            '%d',
            '%d',
            '%s',
            '%s',
            '%s',
            '%s'
        );


        $result = $wpdb->insert(
            $table_name,
            $insert_data,
            $formats
        );

        if ($result) {
            MADL_Logger::log("Added AD profile: " . $data['profile_name'] . " with ID: " . $wpdb->insert_id, 'INFO');
            return $wpdb->insert_id;
        } else {
            MADL_Logger::log("Failed to add AD profile: " . $data['profile_name'] . " - WPDB Error: " . $wpdb->last_error, 'ERROR');
            return false;
        }
    }

    /**
     * Update an existing AD profile.
     * Encrypts bind_password before saving if it's provided.
     *
     * @param int   $id   Profile ID.
     * @param array $data Profile data.
     * @return bool True on success, false on failure.
     */
    public function update_ad_profile($id, $data)
    {
        global $wpdb;
        $id = absint($id);
        $table_name = $this->table_name_instance;

        if (! empty($data['is_default']) && $data['is_default']) {
            $wpdb->query($wpdb->prepare("UPDATE " . $table_name . " SET is_default = 0 WHERE is_default = 1 AND id != %d", $id));
            MADL_Logger::log("Cleared previous default AD profiles before update.", 'DEBUG');
        }

        $update_data = array(
            'profile_name'        => sanitize_text_field($data['profile_name']),
            'is_default'          => ! empty($data['is_default']) ? 1 : 0,
            'domain_identifier'   => isset($data['domain_identifier']) ? sanitize_text_field($data['domain_identifier']) : null,
            'base_dn'             => sanitize_text_field($data['base_dn']),
            'domain_controllers'  => sanitize_textarea_field($data['domain_controllers']),
            'port'                => isset($data['port']) ? absint($data['port']) : 389,
            'use_tls'             => ! empty($data['use_tls']) ? 1 : 0,
            'use_ssl'             => ! empty($data['use_ssl']) ? 1 : 0,
            'allow_self_signed'   => ! empty($data['allow_self_signed']) ? 1 : 0,
            'network_timeout'     => isset($data['network_timeout']) ? absint($data['network_timeout']) : 5,
            'account_suffixes'    => isset($data['account_suffixes']) ? sanitize_textarea_field($data['account_suffixes']) : null,
            'bind_username'       => isset($data['bind_username']) ? sanitize_text_field($data['bind_username']) : null,
        );
        $update_formats = array(
            '%s',
            '%d',
            '%s',
            '%s',
            '%s',
            '%d',
            '%d',
            '%d',
            '%d',
            '%d',
            '%s',
            '%s'
        );

        // Handle password update separately
        // Only update if a new password is provided or if explicitly told to clear it.
        // This prevents overwriting with empty string if field is not submitted.
        if (isset($data['bind_password'])) {
            if (!empty($data['bind_password'])) {
                $encryption_result = $this->encrypt_password($data['bind_password']);
                if ($encryption_result) {
                    $update_data['bind_password'] = $encryption_result['encrypted_password'];
                    $update_data['bind_password_iv'] = $encryption_result['iv'];
                    $update_formats[] = '%s'; // For bind_password
                    $update_formats[] = '%s'; // For bind_password_iv
                } else {
                    MADL_Logger::log("Failed to encrypt bind password for profile ID: " . $id, 'ERROR');
                    return false; // Prevent update if encryption fails
                }
            } elseif (isset($data['clear_bind_password']) && $data['clear_bind_password'] == '1') {
                // Allow explicitly clearing the password
                $update_data['bind_password'] = null;
                $update_data['bind_password_iv'] = null;
                $update_formats[] = '%s'; // For bind_password
                $update_formats[] = '%s'; // For bind_password_iv
            }
        }

        $result = $wpdb->update(
            $table_name,
            $update_data,
            array('id' => $id),
            $update_formats,
            array('%d')
        );

        if ($result !== false) {
            MADL_Logger::log("Updated AD profile ID: " . $id . " (Rows affected: " . $result . ")", 'INFO');
            return true;
        } else {
            MADL_Logger::log("Failed to update AD profile ID: " . $id . " - WPDB Error: " . $wpdb->last_error, 'ERROR');
            return false;
        }
    }

    /**
     * Delete an AD profile.
     *
     * @param int $id Profile ID.
     * @return bool True on success, false on failure.
     */
    public function delete_ad_profile($id)
    {
        global $wpdb;
        $id = absint($id);
        $table_name = $this->table_name_instance;
        $result = $wpdb->delete($table_name, array('id' => $id), array('%d'));

        if ($result) {
            MADL_Logger::log("Deleted AD profile ID: " . $id, 'INFO');
            return true;
        } else {
            MADL_Logger::log("Failed to delete AD profile ID: " . $id . " - WPDB Error: " . $wpdb->last_error, 'ERROR');
            return false;
        }
    }

    /**
     * Get a specific AD profile by ID.
     * Decrypts bind_password before returning.
     *
     * @param int $id Profile ID.
     * @return object|null Profile object or null if not found.
     */
    public static function get_ad_profile($id)
    {
        global $wpdb;
        $id = absint($id);
        $profile = $wpdb->get_row($wpdb->prepare("SELECT * FROM " . self::get_table_name() . " WHERE id = %d", $id));

        if ($profile && !empty($profile->bind_password) && !empty($profile->bind_password_iv)) {
            // Create a temporary instance to access non-static decryption method
            $instance = new self();
            $profile->bind_password = $instance->decrypt_password($profile->bind_password, $profile->bind_password_iv);
            if ($profile->bind_password === false) {
                MADL_Logger::log("Failed to decrypt bind password for profile ID: " . $id, 'ERROR');
                // Optionally, you might want to nullify the password or handle this error more gracefully
                $profile->bind_password = null;
            }
        }
        return $profile;
    }

    /**
     * Get all AD profiles.
     * Decrypts bind_password for each profile before returning.
     *
     * @return array Array of profile objects.
     */
    public static function get_all_ad_profiles()
    {
        global $wpdb;
        $profiles = $wpdb->get_results("SELECT * FROM " . self::get_table_name() . " ORDER BY profile_name ASC");

        if (!empty($profiles)) {
            $instance = new self(); // Create a temporary instance for decryption
            foreach ($profiles as $profile) {
                if (!empty($profile->bind_password) && !empty($profile->bind_password_iv)) {
                    $profile->bind_password = $instance->decrypt_password($profile->bind_password, $profile->bind_password_iv);
                    if ($profile->bind_password === false) {
                        MADL_Logger::log("Failed to decrypt bind password for profile ID: " . $profile->id . " in get_all_ad_profiles.", 'ERROR');
                        $profile->bind_password = null;
                    }
                }
            }
        }
        return $profiles;
    }

    /**
     * Get the default AD profile.
     * Decrypts bind_password before returning.
     *
     * @return object|null Default profile object or null if not found.
     */
    public static function get_default_ad_profile()
    {
        global $wpdb;
        $profile = $wpdb->get_row("SELECT * FROM " . self::get_table_name() . " WHERE is_default = 1 LIMIT 1");

        if ($profile && !empty($profile->bind_password) && !empty($profile->bind_password_iv)) {
            $instance = new self();
            $profile->bind_password = $instance->decrypt_password($profile->bind_password, $profile->bind_password_iv);
            if ($profile->bind_password === false) {
                MADL_Logger::log("Failed to decrypt bind password for default profile.", 'ERROR');
                $profile->bind_password = null;
            }
        }
        return $profile;
    }

    /**
     * Get an AD profile by its domain identifier.
     * Decrypts bind_password before returning.
     *
     * @param string $identifier The domain identifier (e.g., example.com).
     * @return object|null Profile object or null if not found.
     */
    public static function get_ad_profile_by_identifier($identifier)
    {
        global $wpdb;
        $identifier = sanitize_text_field($identifier);
        $profile = $wpdb->get_row($wpdb->prepare("SELECT * FROM " . self::get_table_name() . " WHERE domain_identifier = %s LIMIT 1", $identifier));

        if ($profile && !empty($profile->bind_password) && !empty($profile->bind_password_iv)) {
            $instance = new self();
            $profile->bind_password = $instance->decrypt_password($profile->bind_password, $profile->bind_password_iv);
            if ($profile->bind_password === false) {
                MADL_Logger::log("Failed to decrypt bind password for profile with identifier: " . $identifier, 'ERROR');
                $profile->bind_password = null;
            }
        }
        return $profile;
    }
}
